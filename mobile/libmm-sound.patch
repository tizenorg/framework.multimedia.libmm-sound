diff --git a/mm_sound.c b/mm_sound.c
index 9c08623..94daab8 100644
--- a/mm_sound.c
+++ b/mm_sound.c
@@ -76,6 +76,7 @@ typedef struct {
 	bool 				is_started;
 	bool				is_playback;
 	bool				skip_session;
+	ASM_resource_t resource;
 	pthread_mutex_t pcm_mutex_internal;
 	MMMessageCallback	msg_cb;
 	void *msg_cb_param;
@@ -420,7 +421,7 @@ static void __sound_pcm_send_message (mm_sound_pcm_t *pcmHandle, int message, in
 	}
 }
 
-ASM_cb_result_t sound_pcm_asm_callback(int handle, ASM_event_sources_t event_src, ASM_sound_commands_t command, unsigned int sound_status, void *cb_data)
+static ASM_cb_result_t sound_pcm_asm_callback(int handle, ASM_event_sources_t event_src, ASM_sound_commands_t command, unsigned int sound_status, void *cb_data)
 {
 	mm_sound_pcm_t *pcmHandle = (mm_sound_pcm_t *)cb_data;
 	ASM_cb_result_t	cb_res = ASM_CB_RES_IGNORE;
@@ -434,6 +435,7 @@ ASM_cb_result_t sound_pcm_asm_callback(int handle, ASM_event_sources_t event_src
 	debug_log ("command = %d, handle = %p, is_started = %d\n",command, pcmHandle, pcmHandle->is_started);
 	switch(command)
 	{
+	case ASM_COMMAND_PAUSE:
 	case ASM_COMMAND_STOP:
 		/* Do stop */
 		PCM_LOCK_INTERNAL(&pcmHandle->pcm_mutex_internal);
@@ -446,7 +448,6 @@ ASM_cb_result_t sound_pcm_asm_callback(int handle, ASM_event_sources_t event_src
 		cb_res = ASM_CB_RES_IGNORE;
 		break;
 
-	case ASM_COMMAND_PAUSE:
 	case ASM_COMMAND_PLAY:
 	case ASM_COMMAND_NONE:
 		debug_error ("Not an expected case!!!!\n");
@@ -568,15 +569,17 @@ int mm_sound_pcm_capture_open(MMSoundPcmHandle_t *handle, const unsigned int rat
 		return MM_ERROR_POLICY_INTERNAL;
 	}
 	/* register asm */
-	if(pcmHandle->asm_event != ASM_EVENT_CALL && pcmHandle->asm_event != ASM_EVENT_VIDEOCALL) {
+	if(pcmHandle->asm_event != ASM_EVENT_CALL &&
+		pcmHandle->asm_event != ASM_EVENT_VIDEOCALL) {
 		if(!ASM_register_sound(-1, &pcmHandle->asm_handle, pcmHandle->asm_event,
-				/* ASM_STATE_PLAYING */ ASM_STATE_NONE, sound_pcm_asm_callback, (void*)pcmHandle, ASM_RESOURCE_NONE, &errorcode))
-		{
+				/* ASM_STATE_PLAYING */ ASM_STATE_NONE, sound_pcm_asm_callback, (void*)pcmHandle, pcmHandle->resource, &errorcode)) {
 			debug_error("ASM_register_sound() failed 0x%x\n", errorcode);
 			PCM_LOCK_DESTROY_INTERNAL(&pcmHandle->pcm_mutex_internal);
 			free(pcmHandle);
 			return MM_ERROR_POLICY_BLOCKED;
 		}
+	} else {
+		pcmHandle->skip_session = true;
 	}
 
 	/* Open */
@@ -626,7 +629,7 @@ static int _pcm_sound_start (MMSoundPcmHandle_t handle)
 
 	if (pcmHandle->skip_session == false) {
 		/* ASM set state to PLAYING */
-		if (!ASM_set_sound_state(pcmHandle->asm_handle, pcmHandle->asm_event, ASM_STATE_PLAYING, ASM_RESOURCE_NONE, &errorcode)) {
+		if (!ASM_set_sound_state(pcmHandle->asm_handle, pcmHandle->asm_event, ASM_STATE_PLAYING, pcmHandle->resource, &errorcode)) {
 			debug_error("ASM_set_sound_state(PLAYING) failed 0x%x\n", errorcode);
 			ret = MM_ERROR_POLICY_BLOCKED;
 			goto EXIT;
@@ -719,7 +722,7 @@ static int _pcm_sound_stop(MMSoundPcmHandle_t handle)
 	if (ret == MM_ERROR_NONE) {
 		/* Set ASM State to STOP */
 		if (pcmHandle->skip_session == false) {
-			if (!ASM_set_sound_state(pcmHandle->asm_handle, pcmHandle->asm_event, ASM_STATE_STOP, ASM_RESOURCE_NONE, &errorcode)) {
+			if (!ASM_set_sound_state(pcmHandle->asm_handle, pcmHandle->asm_event, ASM_STATE_STOP, pcmHandle->resource, &errorcode)) {
 				debug_error("ASM_set_sound_state(STOP) failed 0x%x\n", errorcode);
 				ret = MM_ERROR_POLICY_BLOCKED;
 				goto EXIT;
@@ -823,13 +826,16 @@ int mm_sound_pcm_capture_close(MMSoundPcmHandle_t handle)
 	}
 
 	/* Unregister ASM */
-	if(pcmHandle->asm_event != ASM_EVENT_CALL && pcmHandle->asm_event != ASM_EVENT_VIDEOCALL) {
-		if(!ASM_unregister_sound(pcmHandle->asm_handle, pcmHandle->asm_event, &errorcode)) {
-    		debug_error("ASM_unregister failed in %s with 0x%x\n", __func__, errorcode);
-			result = MM_ERROR_SOUND_INTERNAL;
-			goto EXIT;
-    	}
-    }
+	if(pcmHandle->asm_event != ASM_EVENT_CALL &&
+		pcmHandle->asm_event != ASM_EVENT_VIDEOCALL) {
+		if (pcmHandle->skip_session == false && pcmHandle->asm_handle) {
+			if(!ASM_unregister_sound(pcmHandle->asm_handle, pcmHandle->asm_event, &errorcode)) {
+				debug_error("ASM_unregister failed in %s with 0x%x\n", __func__, errorcode);
+				result = MM_ERROR_SOUND_INTERNAL;
+				goto EXIT;
+			}
+		}
+	}
 
 	debug_log ("pcm capture sound [%p] closed success!!!\n", handle);
 
@@ -943,20 +949,23 @@ int mm_sound_pcm_play_open_ex (MMSoundPcmHandle_t *handle, const unsigned int ra
 			return MM_ERROR_POLICY_INTERNAL;
 		}
 
-		if(pcmHandle->asm_event != ASM_EVENT_CALL && pcmHandle->asm_event != ASM_EVENT_VIDEOCALL) {
+		if(pcmHandle->asm_event != ASM_EVENT_CALL &&
+			pcmHandle->asm_event != ASM_EVENT_VIDEOCALL) {
 			/* register asm */
 			if(!ASM_register_sound(-1, &pcmHandle->asm_handle, pcmHandle->asm_event,
-					ASM_STATE_NONE, sound_pcm_asm_callback, (void*)pcmHandle, ASM_RESOURCE_NONE, &errorcode)) {
+					ASM_STATE_NONE, sound_pcm_asm_callback, (void*)pcmHandle, pcmHandle->resource, &errorcode)) {
 				debug_error("ASM_register_sound() failed 0x%x\n", errorcode);
 				PCM_LOCK_DESTROY_INTERNAL(&pcmHandle->pcm_mutex_internal);
 				free(pcmHandle);
 				return MM_ERROR_POLICY_BLOCKED;
 			}
+		} else {
+			pcmHandle->skip_session = true;
 		}
 	} else {
 		/* register asm using asm_event input */
 		if(!ASM_register_sound(-1, &pcmHandle->asm_handle, asm_event,
-				ASM_STATE_NONE, NULL, (void*)pcmHandle, ASM_RESOURCE_NONE, &errorcode)) {
+				ASM_STATE_NONE, NULL, (void*)pcmHandle, pcmHandle->resource, &errorcode)) {
 			debug_error("ASM_register_sound() failed 0x%x\n", errorcode);
 			PCM_LOCK_DESTROY_INTERNAL(&pcmHandle->pcm_mutex_internal);
 			free(pcmHandle);
@@ -1109,7 +1118,8 @@ int mm_sound_pcm_play_close(MMSoundPcmHandle_t handle)
 
 	if (pcmHandle->skip_session == false) {
 		/* Unregister ASM */
-		if(pcmHandle->asm_event != ASM_EVENT_CALL && pcmHandle->asm_event != ASM_EVENT_VIDEOCALL) {
+		if(pcmHandle->asm_event != ASM_EVENT_CALL &&
+			pcmHandle->asm_event != ASM_EVENT_VIDEOCALL) {
 			if(!ASM_unregister_sound(pcmHandle->asm_handle, pcmHandle->asm_event, &errorcode)) {
 				debug_error("ASM_unregister failed in %s with 0x%x\n",__func__, errorcode);
 				result = MM_ERROR_SOUND_INTERNAL;
diff --git a/packaging/libmm-sound.spec b/packaging/libmm-sound.spec
index b07199e..040586d 100644
--- a/packaging/libmm-sound.spec
+++ b/packaging/libmm-sound.spec
@@ -1,6 +1,6 @@
 Name:       libmm-sound
 Summary:    MMSound Package contains client lib and sound_server binary
-Version:    0.7.4
+Version:    0.7.5
 Release:    0
 Group:      System/Libraries
 License:    Apache-2.0
